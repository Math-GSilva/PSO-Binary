# -*- coding: utf-8 -*-
"""N2 Glauco - Otimização por Enxame de Partículas (PSO).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oPltaYzNjNBDlMoWlVuBsYyRUm8wgzM8
"""

pip install matplotlib

import random
import math
import matplotlib.pyplot as plt

# ------------------------------------------
# Função de avaliação
def avaliar(solucao, valores, pesos, capacidade):
    peso_total = sum(pesos[i] for i in range(len(solucao)) if solucao[i] == 1)
    valor_total = sum(valores[i] for i in range(len(solucao)) if solucao[i] == 1)
    if peso_total > capacidade:
        return 0  # Penaliza soluções inválidas
    return valor_total

# ------------------------------------------
# Função para calcular o peso total da mochila
def calcular_peso(solucao, pesos):
    return sum(pesos[i] for i in range(len(solucao)) if solucao[i] == 1)

# ------------------------------------------
# Função sigmoide para binarização da posição da partícula
def sigmoid(x):
    return 1 / (1 + math.exp(-x))

# ------------------------------------------
# Gerador de instâncias do problema da mochila
def gerar_instancia(n_itens=100, capacidade_percentual=0.4):
    pesos = [random.randint(1, 50) for _ in range(n_itens)]
    valores = [random.randint(10, 100) for _ in range(n_itens)]
    capacidade = int(sum(pesos) * capacidade_percentual)
    return valores, pesos, capacidade

# ------------------------------------------
# PSO binário para o problema da mochila
def pso_mochila(valores, pesos, capacidade, n_particulas=30, n_iteracoes=50, c1=1.5, c2=1.5, w=0.8):
    if len(valores) != len(pesos):
        raise ValueError("Listas de valores e pesos devem ter o mesmo tamanho.")

    n = len(valores)
    particulas = [[random.randint(0, 1) for _ in range(n)] for _ in range(n_particulas)]
    velocidades = [[random.uniform(-1, 1) for _ in range(n)] for _ in range(n_particulas)]

    p_best = particulas[:]
    p_best_valores = [avaliar(p, valores, pesos, capacidade) for p in particulas]

    g_best = max(p_best, key=lambda x: avaliar(x, valores, pesos, capacidade))
    g_best_valor = avaliar(g_best, valores, pesos, capacidade)

    historico = []

    for iteracao in range(n_iteracoes):
        for i in range(n_particulas):
            for j in range(n):
                r1 = random.random()
                r2 = random.random()

                velocidades[i][j] = (
                    w * velocidades[i][j] +
                    c1 * r1 * (p_best[i][j] - particulas[i][j]) +
                    c2 * r2 * (g_best[j] - particulas[i][j])
                )

                prob = sigmoid(velocidades[i][j])
                particulas[i][j] = 1 if random.random() < prob else 0

            valor_atual = avaliar(particulas[i], valores, pesos, capacidade)
            if valor_atual > p_best_valores[i]:
                p_best[i] = particulas[i][:]
                p_best_valores[i] = valor_atual

        melhor_index = p_best_valores.index(max(p_best_valores))
        if p_best_valores[melhor_index] > g_best_valor:
            g_best = p_best[melhor_index][:]
            g_best_valor = p_best_valores[melhor_index]

        historico.append(g_best_valor)
        print(f"Iteração {iteracao+1} | Melhor valor: {g_best_valor}")

    return g_best, g_best_valor, historico

# ------------------------------------------
# Execução com múltiplas tentativas
def executar_testes(n_execucoes=10):
    valores, pesos, capacidade = gerar_instancia()
    resultados = []
    historico_melhores = []
    melhor_solucao_global = None
    melhor_valor_global = 0

    for i in range(n_execucoes):
        print(f"\nExecução {i + 1}/{n_execucoes}")
        melhor_solucao, melhor_valor, historico = pso_mochila(valores, pesos, capacidade)
        peso_solucao = calcular_peso(melhor_solucao, pesos)
        print(f"→ Melhor valor da execução: {melhor_valor} | Peso da mochila: {peso_solucao}")
        resultados.append(melhor_valor)
        historico_melhores.append(historico)

        if melhor_valor > melhor_valor_global:
            melhor_valor_global = melhor_valor
            melhor_solucao_global = melhor_solucao

    print("\nEstatísticas após múltiplas execuções:")
    print(f"Média dos melhores valores: {sum(resultados)/len(resultados):.2f}")
    print(f"Melhor valor obtido: {max(resultados)}")
    print(f"Pior valor obtido: {min(resultados)}")

    peso_final = calcular_peso(melhor_solucao_global, pesos)
    print(f"\nMelhor solução global:")
    print(f"Valor: {melhor_valor_global} | Peso: {peso_final}")
    print(f"Mochila (itens levados): {melhor_solucao_global}")

    plt.plot(historico_melhores[0])
    plt.title("Evolução do Melhor Valor (1ª execução)")
    plt.xlabel("Iteração")
    plt.ylabel("Valor")
    plt.grid(True)
    plt.show()

# ------------------------------------------
# Executar módulo principal
if __name__ == "__main__":
    executar_testes(n_execucoes=5)